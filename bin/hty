#! /bin/bash

set -e 

# hty - HPCToys commands 
#
# notes: 
# Expand with https://starship.rs/
#
SCR=${0##*/}
SUBCMD=$1
ME=$(whoami)
STARTDIR=$(pwd)
STARTBASE=$(basename ${STARTDIR})
GITMINFILES=1 # number of files in git after blank init

export DIALOGRC=${HPCTOYS_ROOT}/etc/.dialogrc
source ${HPCTOYS_ROOT}/etc/profile.d/zzz-hpctoys.sh

htyRootCheck || exit

#initLpython

shift
while getopts "a:b:c:d:e:f:g:h:i:j:k:l:m:n:o:p:q:r:s:t:u:v:w:x:y:z:" OPTION; do
  #echo "OPTION: -${OPTION} ARG: ${OPTARG}"
  eval OPT_${OPTION}=\$OPTARG
done
shift $((OPTIND - 1))


# various functions are executed as subcommands 

longterm(){  
  SN=$(tmux list-sessions -F "#S" 2>/dev/null)
  if [[ -z ${SN} ]]; then
QST=$(cat << EOF
Starting a new TMUX session. This will allow you
to have one or more very long running terminal
sessions. You will be able to re-attach to these
sessions even after you disconnected for a long
weekend. If you type 'CTRL+B' and then 'D' you
can detach from the terminal instead of exiting.
Run: tmux new-session -s ${ME}1
EOF
)
    dialog --msgbox  "${QST}" 0 0  
    clear
    htyEcho "Run: tmux new-session -s \"${ME}1\"" ${TWW}
    tmux new-session -s "${ME}1"
    return 0
  fi
  SN+=" -new-session- -exit-"
QST=$(cat << EOF
Please select the terminal session you would
like to re-connect to. You can also create a 
new session. 
You will be able to re-attach to these sessions
even after you disconnected for a long weekend. 
If you type 'CTRL+B' and then 'D' you can detach 
from the terminal instead of exiting.
EOF
)
  if ! htyDialogMenu "${QST}" "${SN}"; then 
    return 1
  fi
  if [[ "${RES}" == "-new-session-" ]]; then
QST=$(cat << EOF
Please confirm the session name or enter a new
session name, for example a project name you 
will be working on for a while. 
If you type 'CTRL+B' and then 'D' you can detach
from the terminal instead of exiting.
EOF
)
    SID=$(wc -w <<<${SN})
    ! htyDialogInputbox "${QST}" "${ME}${SID}" && return 1
    S=${RES// /_}   
    htyEcho "Run: tmux new-session -s \"${S}\"" ${TWW}
    tmux new-session -s "$S"
  elif [[ "${RES}" == "-exit-" ]]; then
    return 0 
  elif [[ -n ${RES} ]]; then
    htyEcho "Run: tmux attach -t \"${RES}\"" ${TWW}
    tmux attach -t "${RES}"
  fi
}

## Create a Slurm job array 

arrayjob() {
  #MSG="${FUNCNAME[0]} <binary> <script>"
  #[[ -z $1 ]] && echo ${MSG} && return 1
  MYBIN=$1;  MYSHEBANG=""; RES=""
  MYJOBARR="${ME}-job-arr1"; 
  [[ $1 == "R" ]] && MYBIN="Rscript"
  [[ $1 == "python" ]] && MYBIN="python3"
QST=$(cat << EOF
We will now create a Slurm job array and submit
it to the cluster. The idea of job arrays is
that you have one script that is executed many 
times and each time with a different data file.
Each combination of script and data file is an
array job and the collection of all data files 
and the script is called a job array.
As part of this process we will use common best 
practices, manage our code with Git, and ensure 
that code and data are kept in separate folders.
Please enter a short but meaningful name or id 
for your job array. You will use it to track 
progress with your compute jobs.
EOF
) 
  MYJOBARR=$(htyReadConfigOrDefault "lastjobarray" "${ME}-job-arr0")
  MYJOBARR=$(htyIncrementTrailingNumber "${MYJOBARR}")	   
  htyDialogInputbox "${QST}" \
      "${MYJOBARR}" "Job Array Name" \
      || return 1
  MYJOBARR=${RES// /-}
  echo "${MYJOBARR}" > ~/.config/hpctoys/lastjobarray
  
QST=$(cat << EOF
Now we select a project folder name that has a 
Python, R, or Shell (other) script but NO data.
If you don't have a project folder with a script 
yet, please enter a new folder name without path 
below and in the next step you use the folder 
browser to select the path where this new folder
will be created. 

If your project folder is not inside a Git repos
yet, this process will initialize a new Git repos
for you. Note, that all dots, underscores and 
spaces in your folder name will be replaced with h
yphens to ensure this folder name can be in a URL 
on Github later.

Enter a project folder name or leave blank to
select an existing folder with the folder browser
in th next step.
EOF
)
  RES=""
  htyDialogInputbox "${QST}" "" \
      "${MYJOBARR} Folder" || return 1
  REPOSFLD=""
  NEWFLD=""

  if [[ -n ${RES} ]]; then
    NEWFLD=${RES}
    QST=$(cat << EOF
Please select a folder in which we create your
new project sub folder "${NEWFLD}".
You can either select a previously used folder
or you start from 'root' or 'home' and browse 
through the folders with the arrow keys and 
confirm your selection with 'Enter'.
EOF
)     
  else
QST=$(cat << EOF
Please select the existing folder that contains 
your code files. This folder cannot exceed 10MB
in size. 
EOF
)
  fi

  htyFolderSel "${QST}" || return 1
  REPOSFLD=${RES}

  if [[ -z ${NEWFLD} ]]; then
    MAXSIZEFLD=10240 # 10MB max size
    SIZEFLD=(du -s "${REPOSFLD}")
    if [[ ${SIZEFLD} -gt ${MAXSIZEFLD} ]]; then
      QST=$(cat << EOF
The folder you chose is larger than 10 MB which
is not supported by HPC Toys. Remember that code
and data must be stored in different locations.
Please enter a new project folder name that 
will be created inside ${REPOSFLD}. 
EOF
)     
      htyDialogInputbox "${QST}" "${ME}-project-1" \
      "${MYJOBARR} Folder" || return 1 
      NEWFLD=${RES}
    fi
  fi

  if [[ -n ${NEWFLD} ]]; then
    NEWFLD=${NEWFLD// /-}
    NEWFLD=${NEWFLD//_/-}
    NEWFLD=${NEWFLD//./-}
    NEWFLD=$(htyRemoveTrailingSlashes "${NEWFLD}")
    eval REPOSFLD=${REPOSFLD}/${NEWFLD}
    mkdir -p "${REPOSFLD}"
    htyEcho "${REPOSFLD}"
  fi

  # REPOSFLD is now set, expand and initialize git repos
  eval REPOSFLD="${REPOSFLD}"
  PLAINFLD=$(basename "${REPOSFLD}")
  GHORG=$(htyReadConfigOrDefault "github_login") 

  
  if ! htyGitIsInRepos "${REPOSFLD}"; then
    if htyGitInitRepos "${REPOSFLD}"; then
       ##########
      QST=$(cat << EOF
Git repository "${PLAINFLD}" was created with:
  git init
  git symbolic-ref HEAD refs/heads/main
  git add -A .
  git commit -a -m "Initial commit" 

Would you also like to create this repostory on
Github? 

If you select 'Yes', I will run these commmands:
  git remote add origin git@github.com:${GHORG}/${PLAINFLD}.git
  git remote -v
  git push --set-upstream origin main
EOF
)
       if dialog --yesno "${QST}" 0 0; then
          if htyGithubInitRepos; then 
            dialog --yesno "Github repos was created !" 0 0
	  fi
       fi      
    fi
  fi

  ####### let's pick the Code file """""""

  MYFILE="- Create New File -"

  # are there even existing files in there ?
  N=$(htyFilesPlain "${REPOSFLD}" | wc -w)
  if [[ $N -gt ${GITMINFILES} ]]; then
    QST=$(cat << EOF
Now select the code file you would like to use
for your array job. This should be a file ending
with .py or .R or .sh. If you are not seeing 
a suitable file please use "- Create New File -"
EOF
)
    htyFileSel "${QST}" "${REPOSFLD}"  "*" "0" \
             "- Create New File -" || return 1
    MYFILE="${RES}"
  fi

  if [[ "${MYFILE}" =~ "- Create New File -" ]]; then
      QST=$(cat << EOF
"${REPOSFLD}" is empty.
Please enter a file name that ends with .py or  
.R! If you do not enter a file extension I will
create a Slurm submission script with an extension
.sub.
EOF
)    
    htyDialogInputbox "${QST}" "" \
	"Create New File" || return 1
      MYFILE="${RES}"
      MYFILE=$(htyRemoveTrailingSlashes "${MYFILE}")
      MYFILE=${MYFILE// /-}
  fi

  touch "${REPOSFLD}/${MYFILE}"

  ## checking if R or Python or Shell 

  MYEXT=${MYFILE##*.}
  if [[ "${MYEXT}" == "${MYFILE}" ]]; then
    MYEXT="sub"
    MYBIN="bash"
  fi
  if [[ "${MYEXT,,}" == "r" ]]; then 
    # converting to lowercase 
    MYEXT='R'
    MYBIN="Rscript"
  elif [[ "${MYEXT,,}" == "py" ]]; then
    MYEXT='py'    
    MYBIN='python3'
  elif [[ "${MYEXT,,}" == "sh" ]]; then
    MYEXT='sh'
    MYBIN='sh'
  fi

  #### Select data files, one and more folders 

  DQST=$(cat << EOF
Now we need to select the folders that contain 
the data files you would like to use. 
You can select data files from multiple folders. 
After you have selected your folder you can 
check multiple files for processing.
EOF
)

  FQST=$(cat << EOF
Now we need to select the data files you would
like to run with your script. You can check files
or simply choose "- all files -" to include all
files in that folder.
EOF
)

  FLDEND=""  # yes = select no more folders
  MYDATA=()  # Array that contains all selected files
  while [[ -z "${FLDEND}" ]]; do 
    htyFolderSel "${DQST}" "" "Select Data Folder" \
               || FLDEND='yes'
    FLD="${RES}"
    NOFILES=""
    INSRT=${#MYDATA[@]}
    N=$(htyFilesPlain "${FLD}" | wc -w)
    if [[ $N -eq 0 ]]; then
      NOFILES="No files found in Folder ${FLD}.\n"
    fi
    if [[ -z "${FLDEND}" ]] && [[ $N -gt 0 ]]; then
      htyFileSelMulti "${FQST}" "${FLD}" "*" "0" \
	"- all files -" || FLDEND='yes'
      if [[ -z "${FLDEND}" ]]; then
	if [[ "${RES}" =~ "- all files -" ]]; then
	  readarray -O ${INSRT} -t \
	         MYDATA < <(htyFilesFull "${FLD}")
	else
	  for F in ${RES}; do 
	    MYDATA+=("${FLD}/${F}")
	  done
	fi
      fi 
    fi
    dialog --yesno "${NOFILES}Select more files from other data folders?" 0 0 \
                   || FLDEND='yes'
  done
  # write MYDATA array to file
  printf "%s\n" "${MYDATA[@]}" \
        > "${REPOSFLD}/${MYJOBARR}-datafiles.txt"
 

  MYSLURM="" # a block with SHEBANG, SBATCH DIRECTIVES
  #check if the script starts with the right shebang
  if ! head -n 1 "${REPOSFLD}/${MYFILE}" | \
                grep -q '^#!.*'"${MYBIN}"'$'; then
    MYSLURM+="#! /usr/bin/env ${MYBIN}\n"
  fi


  #check if the script starts with the right shebang
  #if ! head -n 1 "$2" | grep -q '^#!.*'"${MYBIN}"'$'; then
  #  SHEBANG="#! /usr/bin/env ${MYBIN}"
  #fi
}

spinner() {
  htySpinner "$!"
}


quiet() {
  echo "1" > ~/.config/hpctoys/quiet
  htyEcho "Disabled message at login time."
}

help(){
  echo " ${SCR} longterm"
  echo " ${SCR} arrayjob"
  echo " ${SCR} sshkey (refresh key from .ssh/id_rsa.pub)"
  echo -e "\nfor example:"
  echo -e " ${SCR} create -f ${OPT_f} -i \"${OPT_i}\" myserver"
}

args() {
  while getopts a:b:c:d:e:f:g:h:i:j:k:l:m:n:o:p:q:r:s:t:u:v:w:x:y:z: OPTION "$@"; do
    echo "OPTION: -${OPTION} ARG: ${OPTARG}"
    eval OPT_${OPTION}=\$OPTARG
  done
  shift $((OPTIND - 1))
  printf " arg: '%s'" "$@"
  echo ""
}

if [[ ${SUBCMD} =~ ^(longterm|arrayjob|spiner|quiet|help|args)$ ]]; then
  ${SUBCMD} "$@"  
else
  echo "Invalid subcommand: ${SUBCMD}" >&2
  help
  exit 1
fi

